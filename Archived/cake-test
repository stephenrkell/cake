#!/usr/bin/env python

import sys, os, getopt
import antlr3
import cakeLexer
import cakeParser

def main(argv):
    versionString = "0.0.1test"
    try:								
        opts, args = getopt.getopt(argv, "ho:v", ["help", "outfile=", "version"])
        if len(args) > 1: raise getopt.GetoptError("More than one input file", "")
    except getopt.GetoptError, err:
        sys.stdout.write(str(err) + '\n')
        usage()
        sys.exit(2)
    opts = dict(opts)
    #sys.stderr.write("Options: %s" + str(opts) + "\n")
    if "-h" in opts.keys() or "--help" in opts.keys():
        usage()
        sys.exit(0)
    if "-v" in opts.keys() or "--version" in opts.keys():
        print "Cake version %s" % versionString
        sys.exit(0)    
    inputFilename = args[0]
    parser = None
    try:
        outputFile = sys.stdout if opts.get("-o", opts.get("--outfile", "")) == "" \
        	else file(opts["-o"])
    
        inputStream = antlr3.ANTLRInputStream(file(inputFilename))
        lexer = cakeLexer.cakeLexer(inputStream)
        tokenStream = antlr3.CommonTokenStream(lexer)
        parser = cakeParser.cakeParser(tokenStream)
    except IOError, err:
        sys.stderr.write(str(err) + '\n')

    def printTree(t):
        if t.token != None:
            sys.stdout.write(str(t.token))
        else:
            print "none"
#        for c in t.children:
#            sys.stdout.write("(")
#            printTree(c)
#            sys.stdout.write(") ")
    
    def processToplevel(node):
        outputFile.write("# Makefile generated by cake, version %s\n" % versionString)
        outputFile.write("# Do not edit!\n\n")
        anonCounter = [0]
        
        def processFileNode(node, targetName):
            return targetName # files are already made -- hooray
        
        def processObjectExpr(node):
            return {
                'link' : lambda n: processLinkNode(n, "anon%d.o" % anonCounter[0]),
                'file' : lambda n: processFileNode(n, str(n.children[0]))
            }[str(node)](node)

        def processLinkNode(node, targetName):
            # recursively emit child targets
            dependencies = ""
            for child in node.children:
                exprTargetName = processObjectExpr(child)
                dependencies += "%s " % exprTargetName
            # now we know that rules for all our dependencies have been output
            outputFile.write("%s: %s" % (targetName, dependencies))
            outputFile.write("\n\t" + 'ld ${LDFLAGS} -o "$@" ' + dependencies)
            outputFile.write("\n\n")
            return targetName
        
        return processObjectExpr(node)
        

    #processToplevel(parser.toplevel().tree)
    t = parser.toplevel().tree
    print
    printTree(t) #  sed "s/\[@[0-9]*,[0-9]*:[0-9]*=u'\([^']*\)',<[0-9]*>,[0-9]*:[0-9]*\]/\1/g"

def usage():
    name = os.path.basename(sys.argv[0])
    print "Usage:\n"
    print name + "\t [ -o | --outfile output-file ] input-file"
    print name + "\t   -h | --help"
    print name + "\t   -v | --version"


if __name__ == "__main__":
    main(sys.argv[1:])

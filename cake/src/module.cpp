#include <gcj/cni.h>
#include <string>
#include <cassert>
#include <iostream>
#include "cake.hpp" // includes module.hpp
#include "util.hpp"
#include "treewalk_helpers.hpp"

namespace cake
{
	/* define static members */
	module::constructor_map_entry module::known_constructor_extensions[] = {
			make_pair(std::string("elf_reloc"), std::string("o")),
			make_pair(std::string("elf_external_sharedlib"), std::string("so"))
	};	
	std::map<std::string, std::string> module::known_constructors(
		&module::known_constructor_extensions[0],
		&known_constructor_extensions[(sizeof known_constructor_extensions) 
			/ sizeof (module::constructor_map_entry)
		]
	);
	
	void module::process_exists_claims(antlr::tree::Tree *existsBody)
	{
		FOR_ALL_CHILDREN(existsBody)
		{
			INIT;
			SELECT_NOT(LR_DOUBLE_ARROW); // we don't want rewrites, only claimGroups
			process_claimgroup(n);
		}
	}
	
	void module::process_claimgroup(antlr::tree::Tree *claimGroup)
	{
		INIT;
		switch(claimGroup->getType())
		{
			case cakeJavaParser::KEYWORD_CHECK:
			case cakeJavaParser::KEYWORD_DECLARE:
			case cakeJavaParser::KEYWORD_OVERRIDE:
				std::cerr << "Presented with a claim list of strength " << CCP(claimGroup->getText())
					<< std::endl;
				eval_claim_depthfirst(claimGroup, handler_for_claim_strength(claimGroup), (Dwarf_Off) 0);		
			break;
			default: RAISE_INTERNAL(claimGroup, "bad claim strength (expected `check', `declare' or `override')");
		}			
	}
	
	bool elf_module::do_nothing_handler(antlr::tree::Tree *falsifiable, Dwarf_Off falsifier)
	{
		std::cerr << "DO_NOTHING found falsifying module info, at token " << CCP(falsifiable->getText())
			<< ", die offset " << falsifier << ", aborting" << std::endl;		
		return false;	
	}
	
	bool elf_module::check_handler(antlr::tree::Tree *falsifiable, Dwarf_Off falsifier)
	{
		std::cerr << "CHECK found falsifying module info, at token " << CCP(falsifiable->getText())
			<< ", die offset " << falsifier << ", aborting" << std::endl;
		
		return false;		
	}
	bool elf_module::declare_handler(antlr::tree::Tree *falsifiable, Dwarf_Off falsifier)
	{
		std::cerr << "DECLARE found falsifying module info, at token " << CCP(falsifiable->getText())
			<< ", die offset " << falsifier << ", aborting" << std::endl;
		
		// FIXME: want to nondestructively make the predicate true
		
		return false;	
	}
	bool elf_module::override_handler(antlr::tree::Tree *falsifiable, Dwarf_Off falsifier)
	{
		std::cerr << "OVERRIDE found falsifying module info, at token " << CCP(falsifiable->getText())
			<< ", die offset " << falsifier << ", continuing" << std::endl;
		
		// We want to alter the DWARF info to make the predicate true, destructively if necessary
		if (falsifiable->getType() == cakeJavaParser::DEFINITE_MEMBER_NAME
		&&  info.get_dies()[falsifier].tag() == DW_TAG_compile_unit)
		{
			// add a child DIE to the CU DIE, corresponding to the member
			Dwarf_Off cu_member_off = next_private_offset();
			
			std::map<Dwarf_Half, dwarf::encap::attribute_value> attrs;
			std::vector<Dwarf_Off> children;
			
			dwarf::abi_information::dieset::value_type new_entry(
				cu_member_off, // we mostly fill in placeholders for now
				dwarf::encap::die(
					*this, 0, cu_member_off, cu_member_off - falsifier, attrs, children) 
				);
			
			info.get_dies().insert(new_entry);
			info.get_dies()[falsifier].children().push_back(cu_member_off);
			
			// build and merge a set of DIEs corresponding to the missing member
			antlr::tree::Tree *valueDescriptionExpr = falsifiable->getParent()->getChild(1); // HACK to get sibling
			assert(valueDescriptionExpr->getType() == cakeJavaParser::VALUE_DESCRIPTION);
			
			return build_value_description_handler(valueDescriptionExpr, cu_member_off)
				// self-test: now evaluate the claim again, and it should be true!
				&& eval_claim_depthfirst(falsifiable, 
					&cake::module::do_nothing_handler, 
					falsifier);			
		}
		
		return false;	
	}
	
	void elf_module::make_default_subprogram(dwarf::encap::die &die_to_modify)
	{
		die_to_modify.set_tag(DW_TAG_subprogram);
		/* attributes generated by gcc 4.x for a C function.
		        Attribute type: DW_AT_decl_file; form: DW_FORM_data1; value: (unsigned) 1
                Attribute type: DW_AT_decl_line; form: DW_FORM_data1; value: (unsigned) 27
                Attribute type: DW_AT_prototyped; form: DW_FORM_flag; value: (flag) true
                Attribute type: DW_AT_low_pc; form: DW_FORM_addr; value: (can't print value)
                Attribute type: DW_AT_high_pc; form: DW_FORM_addr; value: (can't print value)
				-- we don't need to set any of the above, I hope
                Attribute type: DW_AT_frame_base; form: DW_FORM_data4; value: (reference, nonglobal)
				-- we should set this to something default according to calling convention
                Attribute type: DW_AT_type; form: DW_FORM_ref4; value: (reference, nonglobal) 0xe0
				-- our called should set this
		*/
		die_to_modify.attrs().insert(std::make_pair(DW_AT_frame_base, (Dwarf_Off) 0UL));
			// FIXME: write a meaningful DW_AT_frame_base here!
		

		
	}	
	
	std::vector<Dwarf_Off> *elf_module::find_dwarf_type(antlr::tree::Tree *description)
	{
		/* From a value description in Cake abstract syntax, find *all* DWARF types
		 * (if any) that satisfy the description. */
		std::vector<Dwarf_Off> retval = new std::vector<Dwarf_Off>();

		// This can be built recursively too: just walk the DWARF type records and call out
		// to an "add to list" function when we find a match
		
		 
		// FIXME: warn the user somehow if their overriding/declared value description is ambiguous
		return retval;
	}
	
	Dwarf_Off elf_module::ensure_dwarf_type(antlr::tree::Tree *description)	
	{
		auto_ptr<std::vector<Dwarf_Off> > list = find_dwarf_type(description);
		if (list->size() >= 1) return *(list.begin());
		else
		{
			
			// there is no type, so make one
		}
	}
	
	//build_dwarf_type -- again, recursive just like build_value_description_handler is
	
	bool elf_module::build_value_description_handler(antlr::tree::Tree *falsifiable, Dwarf_Off falsifier)
	{
		switch(falsifiable->getType())
		{
			case cakeJavaParser::LR_SINGLE_ARROW:
				// fill in default values for various attributes
				make_default_subprogram(info.get_dies()[falsifier]);
				// and return value (attribite of DW_AT_type, pointing to return type)
				INIT;
				BIND2(falsifiable, functionArgumentDescriptionExpr);
				BIND2(falsifiable, functionResultDescriptionExpr);

				// find a DWARF type that satisfies the return value description expression
				
				
				info.get_dies()[falsifier].insert(std::make_pair(DW_AT_type,
					dwarf::encap::die(dwarf::encap::die:ref(ensure_dwarf_type(
						functionResultDescriptionExpr
					), false))));

				// now process arguments (children of DW_TAG_formal_parameter) 
				info.get_dies()[falsifier].children().
				
				return true;
			default:
				std::cerr << "Asked to build a DWARF type from unsupported value description node: "
					<< CCP(falsifiable->getText()) << std::endl;
				return false;
			break;
		}		
	}
	
	module::eval_event_handler_t elf_module::handler_for_claim_strength(antlr::tree::Tree *strength)
	{
		return
			strength->getType() == cakeJavaParser::KEYWORD_CHECK 	? &cake::module::check_handler
		: 	strength->getType() == cakeJavaParser::KEYWORD_DECLARE 	? &cake::module::declare_handler
		: 	strength->getType() == cakeJavaParser::KEYWORD_OVERRIDE ? &cake::module::override_handler : 0;
	}
	
// from earlier notes:
/*	
	component elf_reloc("switch.o") switch12 {
        override {
                .gtk_dialog_new : _ -> GtkDialog ptr
        }
        declare {
                .gtk_dialog_new : _ -> object { .vbox: opaque } ptr
        }
}

(Use of named member entities asserts their existence, Russell-style, with the assertion semantics
of the containing block.)

This syntax isn't ideal, because implicitly we're overriding all the way from the root. For example,
if switch12 turned out not to have an element .gtk_dialog_new, we would be overriding this and
asserting that it does. So we really want finer grain, i.e. the ability to change from "check" or
"declare" to "assert" mid-tree. This will complicate the syntax, so I won't do this yet.
*/
	
	
	bool elf_module::eval_claim_depthfirst(antlr::tree::Tree *claim, eval_event_handler_t handler,
		Dwarf_Off current_die)
	{
		switch(claim->getType())
		{
			// separate out the cases where we have a list of claims about members
			case cakeJavaParser::KEYWORD_CHECK:
			case cakeJavaParser::KEYWORD_DECLARE:
			case cakeJavaParser::KEYWORD_OVERRIDE:
			case cakeJavaParser::KEYWORD_OBJECT:
				if (current_die == 0) // toplevel claim group
				{
					/* SPECIAL CASE: because we want to ignore information on compilation units, 
					 * we loop through each compilation unit when evaluating a toplevel claim.
					 * Each immediate subclaim will be about membership, so we just want *any*
					 * compilation unit to satisfy it. */
					bool all_claims_sat = true;
					bool any_cu_sat = false;
					FOR_ALL_CHILDREN(claim) // for all *claims*
					{
						INIT;
						bool this_cu_sat = false;
						ALIAS3(n, claimHeader, cakeJavaParser::CLAIM); // skip over the CLAIM token
						BIND2(n, memberName); // either `_' or a memberClaim
						BIND2(n, valueDescriptionExpr);
						if (memberName->getType() == '_') RAISE_INTERNAL(memberName, "`_' is not allowed at module level");
						std::vector<Dwarf_Off>::iterator i_cu;
						for (i_cu = info.get_compilation_units().first.begin();
							i_cu != info.get_compilation_units().first.end();
							i_cu++)
						{
							std::cerr << "Trying claim about member " << CCP(memberName->getText()) << " in compilation unit " << info.get_compilation_units().second[*i_cu][DW_AT_name].get_string() << std::endl;
							
							/* This is a CLAIM, so of the form "member : predicate".
							 * We check that the member exists, and that it satisfies
							 * the predicate.							
							 */
							definite_member_name mn = read_definite_member_name(memberName);
							dwarf::encap::die& parent = info.get_compilation_units().second[*i_cu];
							std::vector<Dwarf_Off>::iterator i_child;
							for (i_child = parent.children().begin();
								i_child != parent.children().end();
								i_child++)
							{	
								dwarf::encap::die& child = info.get_dies()[*i_child];
								this_cu_sat |= ( // 1. child must be something we understand
									(	child.tag() == DW_TAG_subprogram
									|| 	child.tag() == DW_TAG_variable )
								// 2. child must have the name given
								&&  (	child[DW_AT_name].get_string() == mn[0]
								/* FIXME: need proper n-deep finding of members, for multipart memberNames */
									)
								&& eval_claim_depthfirst(valueDescriptionExpr, handler, *i_child)
								);
								
								if (this_cu_sat) break; // succeed-fast
							}
							if (!this_cu_sat) /* DO NOTHING -- try the next cu */ {}
							any_cu_sat |= this_cu_sat;
							if (any_cu_sat) break;
						} // end for all compilation units
						
						/* Now we've tried all compilation units. If we still haven't satisfied
						 * the predicate, call the handler passing the *last* compilation unit.
						 * FIXME: this is a bit of a hack. It's okay because we don't care about
						 * how the input is divided into compilation units. However, it will bite
						 * us if e.g. one compilation unit defines functions/types/variables with
						 * the same name as each other but different definitions.
						 */
						if (!any_cu_sat) any_cu_sat |= (this->*handler)(memberName, *(i_cu - 1));
					}
					all_claims_sat &= any_cu_sat;
					if (!all_claims_sat) all_claims_sat |= (this->*handler)(claim, current_die); // fallback
					return all_claims_sat;
				}
				else
				{
					assert(claim->getType() == cakeJavaParser::KEYWORD_OBJECT && current_die != 0);
					
					// check the current die: it must be something that has members
					switch (info.get_dies().find(current_die)->second.get_tag())
					{
						case DW_TAG_compile_unit:
						case DW_TAG_structure_type:
						case DW_TAG_class_type:
						case DW_TAG_enumeration_type:
						case DW_TAG_interface_type:
						case DW_TAG_set_type:
						case DW_TAG_union_type:
							break; // this is okay
						default:
							RAISE_INTERNAL(claim, "found a membership claim about a structureless object");
					}
					
					// now process each immediate subclaim in turn
					bool sat = true;
					FOR_ALL_CHILDREN(claim)
					{
						INIT;
						ALIAS3(n, claimHeader, cakeJavaParser::CLAIM); // skip over the CLAIM token
						BIND2(n, memberName); // either `_' or a memberName
						definite_member_name name;
						switch (memberName->getType())
						{
							case '_':
								std::cerr << "Claim concerns all remaining members" << std::endl;
								// FIXME: now do something
								sat &= true;							
							break;
							case cakeJavaParser::DEFINITE_MEMBER_NAME:
								definite_member_name list = read_definite_member_name(memberName);
								std::cerr << "Claim concerns member ";
								for (definite_member_name::iterator i = list.begin(); i != list.end(); i++)
								{
									std::cerr << *i;
									if (i + 1 != list.end()) std::cerr << " :: ";
								}
								std::cerr << std::endl;
								// FIXME: now do something and recurse
								sat &= true;
							break;						
						}
						if (!sat) sat |= (this->*handler)(claim, current_die); // fallback
						if (!sat) break; // fail fast
					} // end FOR_ALL_CHILDREN
					
					return sat;
				} // end else we_have_an_object
			break;
			default: return false;
		}	// end switch	
	} // end function

	void elf_module::print_abi_info()
	{
		std::cerr << "Got ABI information for file " << get_filename() << ", " 
			<< info.func_offsets().size() << " function entries, " 
			<< info.toplevel_var_offsets().size() << " toplevel variable entries, "
			<< info.type_offsets().size() << " type entries" << std::endl;
			
		for (std::vector<Dwarf_Off>::iterator i = info.func_offsets().begin();
			i != info.func_offsets().end();
			i++)
		{
			std::cerr << "offset: " << std::hex << *i << std::dec;
			if (info.func_dies()[*i][DW_AT_name] != dwarf::encap::attribute_value::DOES_NOT_EXIST())
			{
				std::cerr << ", name: " << info.func_dies()[*i][DW_AT_name].get_string() << std::endl;
			}
			else
			{
				std::cerr << ", no DW_AT_name attribute" << std::endl;
			}
		}
		for (std::vector<Dwarf_Off>::iterator i = info.toplevel_var_offsets().begin();
			i != info.toplevel_var_offsets().end();
			i++)
		{
			std::cerr << "offset: " << std::hex << *i << std::dec;
			if (info.toplevel_var_dies()[*i][DW_AT_name] != dwarf::encap::attribute_value::DOES_NOT_EXIST())
			{
				std::cerr << ", name: " << info.toplevel_var_dies()[*i][DW_AT_name].get_string() << std::endl;
			}
			else
			{
				std::cerr << ", no DW_AT_name attribute" << std::endl;
			}
		}
		for (std::vector<Dwarf_Off>::iterator i = info.type_offsets().begin();
			i != info.type_offsets().end();
			i++)
		{
			std::cerr << "offset: " << std::hex << *i << std::dec;
			if (info.type_dies()[*i][DW_AT_name] != dwarf::encap::attribute_value::DOES_NOT_EXIST())
			{
				std::cerr << ", name: " << info.type_dies()[*i][DW_AT_name].get_string() << std::endl;
			}
			else
			{
				std::cerr << ", no DW_AT_name attribute" << std::endl;
			}
		}
	}
}

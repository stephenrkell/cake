Error-handling:

- return status versus error global (see libdwarfpp)
- zero-is-success versus nonzero-is-success

Return values:

- out argument style versus returning style (see libdwarfpp)

Behaviour:

- asynchronous versus synchronous style
- virtual dispatch style (i.e. interpret a vtable as a single entry point, as if doing switch(){})

Symbol renaming:

- name mangling style
- casing style: use to induce additional name-matching (as in XCL)

Cake-primitive data types:

- strings
- sets

Iteration styles

- arrays, lists, ...

Mux/demux-based styles:

- write/read as request-write and response-read for some proto
- connect/close for the same
- layering (composable) versions of the same, i.e. HTTP style then GET/POST style?
- REPL/ftp-like style: mux a set of functions into an ftp-like read/write console interface
- exec()-based invocation of a command-line tool

Idea: adapt http read--write fd as command-line execve() tool, using w3 validator example
-- first interpret sockets API to a raw TCP read/write fd
-- then interpret raw write/read as HTTP POST/response cycle (params: host, port; WITH PROTOCOL OPTIONS?)
-- -- PROBLEM: want to SLICE fread/fwrite interface s.t. interleaving other reads/writes has no effect
-- then interpret write/read as command-line tool (copy from stdin or named file) (WITH CMDLINE OPTIONS?)
Why is this better than a simple pipeline / chain-of-modules?
I want the answer to be that it is more compositional.
Seems that you can do equally well using C++ templates...?
... but not if you use dynamic features like sequence recognition
... also not if you use universal quantification, since templates can't quantify over "all members"
----- YES, this is a key benefit -- same as my unw_read_ptr:
      I wanted to quantify over all pointer members of a struct, to make them unw_read_ptrs
	  but can' do this

It seems like mux/demux-based styles are really doing something different from the other stuff.
They're neat because they're composable -- they're like mixins.

** They're better than mixins because they're declarative -- they simply define an interpretation,
and no run-time instantiation is involved.

** To apply them, we need to specialise them with the lower-layer stuff that we want to "pull out",
e.g. an XMLRPC description of the interface that we want to pull out of fwrite() etc. This is best
done in a meta-DWARF fashion, i.e. defining a mapping between Dwarf and XMLRPC interfaces, then in
the Cake source just using the DWARF version.

** See what I wrote on the back of the Pidgin paper.

** I think the minimum demonstration of styles in Cake should be a make-like inference application,
where at least two hops of "inference" a.k.a. interpretation are involved, and where the same
interpretation step (mixin) is applied to at least two base components, and where one component is
interpreted in at least two different ways [in the same composition?].

** Surely other styles are potentially composable too? It's just that we tend not to get, say, style
interpretations which reveal new encodings of integers which might then be interperable as bitfield
sets or whatever. One example though: integers interperable as object identities (like Dwarf_Off
values!) which can be lifted to linked structures and then traversed just as if they were pointers).
